{
  "AI_READ_ME_FIRST": {
    "project": "SDK_ProcAmp Wind Lines Effect",
    "version": "v60 - 2026-02-01",
    "status": "STABLE - All features working on Mac/Metal and Windows/CUDA",
    "last_critical_fix": "v55: Appear/Disappear scale+fade - smooth fade-in/out to prevent abrupt pop"
  },
  
  "QUICK_REF": {
    "cpu": "SDK_ProcAmp_CPU.cpp",
    "gpu_cuda": "SDK_ProcAmp.cu (729 lines - REFERENCE)",
    "gpu_opencl": "SDK_ProcAmp.cl (642 lines)",
    "gpu_metal": "SDK_ProcAmp.metal (just includes .cl)",
    "host": "SDK_ProcAmp_GPU.cpp",
    "log": "/Users/kiyotonakamura/Desktop/SDK_ProcAmp_Debug.log"
  },
  
  "CRITICAL_RULES": {
    "multi_platform": "Update ALL THREE: CPU, CUDA, OpenCL when adding features",
    "cuda_is_reference": "CUDA is canonical - port to OpenCL/Metal",
    "metal_uses_opencl": "Metal includes OpenCL - maintain .cl only"
  },

  "V55_APPEAR_DISAPPEAR_SCALE_FADE": {
    "problem": "Lines appear/disappear abruptly (pop in/out)",
    "solution": "Added smooth scale + alpha fade animation at start and end of line lifetime",
    "implementation": {
      "appear": "First 5% of lifetime: easeOutQuad scale 0→1 AND alpha 0→1",
      "disappear": "Last 5% of lifetime: easeInQuad scale 1→0 AND alpha 1→0",
      "applied_to": {
        "scale": ["halfLen", "halfThick"],
        "alpha": ["coverage (line)", "scoverage (shadow)"]
      },
      "formula": "eased = 1 - (1 - t/0.05)^2 for appear, eased = ((1 - t) / 0.05)^2 for disappear"
    },
    "data_structure_change": {
      "lineData": "Now 4 Float4s per line (was 3): d0=position, d1=size, d2=color+velocity, d3=appearAlpha",
      "base_index": "lineIndex * 4 (was lineIndex * 3)"
    },
    "files_modified": ["SDK_ProcAmp_GPU.cpp", "SDK_ProcAmp_CPU.cpp", "SDK_ProcAmp.cu", "SDK_ProcAmp.cl"]
  },

  "V53_FIX_CRITICAL": {
    "problem": "Lines not rendering on Mac/Metal (CUDA worked fine)",
    "symptom": "No lines visible, no errors, kernel appeared to run",
    "root_cause": "Brace/bracket mismatch in SDK_ProcAmp.cl - line drawing code was INSIDE shadow if-block",
    "bad_code_structure": "if (inShadowEnable != 0) { shadow code... line color... line drawing... } // WRONG - line drawing inside shadow block!",
    "correct_structure": "if (inShadowEnable != 0) { shadow code only } // then line drawing OUTSIDE",
    "why_hard_to_find": [
      "No compile errors - syntax was valid",
      "No runtime errors - kernel executed",
      "CUDA version had correct structure - comparing line-by-line missed structural difference",
      "Indentation in .cl file was misleading - code looked correct visually"
    ],
    "debug_approach": [
      "1. Add simple test shape (red rectangle) to verify kernel runs",
      "2. If test shape appears, kernel pipeline is OK",
      "3. Problem is in rendering logic, not data passing",
      "4. Compare CUDA vs OpenCL STRUCTURE, not just syntax",
      "5. Check every if/else/for block has matching braces"
    ],
    "lesson": "When porting CUDA to OpenCL, verify BLOCK STRUCTURE matches exactly, not just line content"
  },
  
  "FLAT_ROUND_CAP_FIX": {
    "problem": "Flat/Round cap styles not switching correctly on Mac/Metal",
    "parameter": "inLineCap: 0 = Flat (box SDF), 1 = Round (capsule SDF)",
    "symptom": "Cap style appears stuck or wrong shape regardless of setting",
    "root_cause": "Same as V53 - if cap logic is inside wrong conditional block, only one path executes",
    "correct_implementation": {
      "locations_in_kernel": [
        "Shadow distance calculation (sdist)",
        "Line distance calculation (dist)"
      ],
      "flat_cap_sdf": {
        "description": "Box signed distance field",
        "code": [
          "float dxBox = fabs(px) - halfLen;",
          "float dyBox = fabs(py) - halfThick;",
          "float ox = dxBox > 0.0f ? dxBox : 0.0f;",
          "float oy = dyBox > 0.0f ? dyBox : 0.0f;",
          "float outside = sqrt(ox * ox + oy * oy);",
          "float inside = fmin(fmax(dxBox, dyBox), 0.0f);",
          "dist = outside + inside;"
        ]
      },
      "round_cap_sdf": {
        "description": "Capsule signed distance field",
        "code": [
          "float ax = fabs(px) - halfLen;",
          "float qx = ax > 0.0f ? ax : 0.0f;",
          "dist = sqrt(qx * qx + py * py) - halfThick;"
        ]
      }
    },
    "verification_steps": [
      "1. Ensure inLineCap parameter is passed to kernel (check buffer index)",
      "2. Verify if (inLineCap == 0) block is NOT inside another conditional",
      "3. Both shadow AND line drawing sections need the cap check",
      "4. Test with thick lines (thickness > 10) to see cap shape clearly"
    ],
    "common_mistakes": [
      "Cap check inside shadow-only block - line drawing ignores cap setting",
      "Using wrong variable name (lineCap vs inLineCap)",
      "Missing cap check in one of the three distance calculations"
    ],
    "reference": "CUDA SDK_ProcAmp.cu lines 252, 330, 374 have correct implementation"
  },
  
  "MOTION_BLUR_FIX": {
    "problem": "Motion blur implementation unified and corrected",
    "correct_behavior": "Motion blur now always trails BEHIND the moving line with standard uniform temporal sampling",
    "changes_v54": [
      "Removed SDK_PROCAMP_MOTION_BLUR_TYPE parameter from SDK_ProcAmp.h",
      "Removed MOTION_BLUR_TYPE_DFLT definition",
      "Removed blur type popup from SDK_ProcAmp_CPU.cpp ParamsSetup",
      "Fixed motionBlurType to 0 (Trail mode) in SDK_ProcAmp_GPU.cpp",
      "Removed type branching from SDK_ProcAmp.cl and SDK_ProcAmp.cu",
      "Removed P_BLUR_TYPE and related strings from SDK_ProcAmp_ParamNames.h"
    ],
    "changes_v54_1": [
      "CUDA implementation now matches OpenCL/Metal exactly",
      "Both use uniform temporal sampling with simple averaging",
      "Both use lineVelocity (instantaneous velocity from easing) for physically correct blur",
      "blurRange = effectiveVelocity * shutterFraction (where effectiveVelocity = pixelsPerFrame * lineVelocity)"
    ],
    "algorithm": {
      "description": "Standard motion blur with uniform temporal sampling",
      "formula": "coverage = Σ(sampleCoverage[i]) / numSamples",
      "sample_distribution": "Evenly distributed from -blurRange to 0 (trail behind)",
      "velocity_linked": "Blur length scales with instantaneous velocity (fast movement = longer blur)"
    },
    "files_modified": ["SDK_ProcAmp.h", "SDK_ProcAmp_CPU.cpp", "SDK_ProcAmp_GPU.cpp", "SDK_ProcAmp.cu", "SDK_ProcAmp.cl", "SDK_ProcAmp_ParamNames.h"]
  },
  
  "V51_FIX": {
    "problem": "Start Time/Duration not working on Mac",
    "cause": "Mac GPU-only rendering skips CPU, SharedClipData empty",
    "solution": "GPU fallback: clipStartFrame = GetClipStart() OR (mediaFrameIndex - clipOffset)",
    "result": "All parameters working on Mac and Windows"
  },
  
  "FRAME_CALCULATION": {
    "formula": "frameIndex = mediaFrameIndex - clipStartFrame",
    "mediaFrameIndex": "clipTime / ticksPerFrame",
    "clipStartFrame": "from CPU GetClipStart() or GPU fallback",
    "clipOffset": "Premiere parameter, 0 at clip start"
  },
  
  "GPU_SYNTAX_DIFF": {
    "decorators": {
      "cuda": "__device__ __forceinline__, __global__",
      "opencl": "inline, __kernel"
    },
    "math": {
      "cuda": "cosf, sinf, powf, fmaxf, fabsf, sqrtf, fminf",
      "opencl": "cos, sin, pow, fmax, fabs, sqrt, fmin"
    },
    "atomic": {
      "cuda": "atomicAdd(&counter[0], 1)",
      "opencl": "atomic_add(&counter[0], 1)",
      "metal": "atomic_fetch_add_explicit((device atomic_uint*)&counter[0], 1, memory_order_relaxed)"
    },
    "float4_init": {
      "cuda": "make_float4(0.0f, 0.0f, 0.0f, 0.0f)",
      "opencl": "(float4)(0.0f, 0.0f, 0.0f, 0.0f)"
    }
  },
  
  "METAL_GOTCHAS": {
    "buffer_init": "Never create Metal buffer with nullptr - use dummy data",
    "cpu_not_called": "Mac GPU-only may skip CPU - GPU needs fallback",
    "brace_structure": "OpenCL/Metal .cl file brace structure MUST match CUDA exactly"
  },
  
  "DEBUGGING_METAL_ISSUES": {
    "step1_verify_kernel_runs": "Add visible test shape (colored rectangle) at start of kernel",
    "step2_check_data_passing": "Visualize tile counts or line data with color coding",
    "step3_isolate_logic": "Comment out sections to find which block causes issue",
    "step4_compare_structure": "Use diff tool on CUDA vs OpenCL, focus on { } balance",
    "common_traps": [
      "Indentation looks correct but braces are wrong",
      "Code inside conditional that should be outside",
      "Missing closing brace causes entire section to be conditional",
      "OpenCL has no compiler warning for valid-but-wrong logic"
    ]
  },
  
  "BUILD": {
    "mac": "xcodebuild ARCHS=arm64, install to /Library/Application Support/Adobe/.../MediaCore/",
    "mac_clean": "xcodebuild clean before testing .cl changes - metallib may be cached",
    "windows": "Visual Studio SDK_ProcAmp.vcxproj"
  },
  
  "FEATURES": {
    "line_animation": "Head extends (tail fixed) → tail retracts (head fixed)",
    "wind_origin": "Adjusts spawn area position, NOT per-line animation",
    "color_system": "Single/Preset(33)/Custom(8) with per-line random selection",
    "blend_modes": "Back/Front/BackAndFront/AlphaXOR",
    "focus_dof": "Pseudo-blur via thickness + alpha (no Gaussian)",
    "effect_presets": "One-click parameter batch update (8 presets)",
    "spawn_scale": "X/Y separate spawn area expansion",
    "shadows": "Offset shadow with configurable color/offset/opacity"
  },
  
  "DO_NOT": [
    "Use seqTime for frame calc (cache issues)",
    "Use instance state for clip tracking (thread conflicts)",
    "Use mNodeID as key (changes frequently)",
    "Mix originOffset into line animation (spawn area only)",
    "Create Metal buffer with nullptr",
    "Use AEFX_CLR_STRUCT for param updates (loses metadata)",
    "Forget debounce for interactive controls",
    "Skip CPU implementation when adding GPU features",
    "Trust indentation in .cl files - always verify brace matching",
    "Assume 'no errors' means 'code is correct' in GPU kernels"
  ],
  
  "AI_TROUBLESHOOTING": {
    "mac_lines_not_rendering": "CHECK BRACE STRUCTURE FIRST - see V53_FIX_CRITICAL",
    "flat_round_not_working": "See FLAT_ROUND_CAP_FIX - check if cap logic is inside wrong conditional block, verify inLineCap passed correctly",
    "mac_bug": "Check SharedClipData, Metal buffer init, atomic syntax, BRACE STRUCTURE",
    "frame_timing": "Verify frameIndex calc, SharedClipData populated, GPU fallback",
    "param_not_updating": "Check SUPERVISE flag, params[] direct use, UpdateParamUI",
    "new_feature": "1.CUDA 2.OpenCL 3.CPU 4.Test both platforms 5.Update this JSON"
  }
}
