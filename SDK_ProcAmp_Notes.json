{
  "AI_READ_ME_FIRST": {
    "project": "SDK_ProcAmp Wind Lines Effect",
    "version": "v62 - 2026-02-02",
    "status": "STABLE - Premultiplied alpha compositing fix complete",
    "last_critical_fix": "v62: Fixed gray edge artifacts by using premultiplied alpha compositing throughout"
  },
  
  "QUICK_REF": {
    "cpu": "SDK_ProcAmp_CPU.cpp",
    "gpu_cuda": "SDK_ProcAmp.cu (729 lines - REFERENCE)",
    "gpu_opencl": "SDK_ProcAmp.cl (733 lines)",
    "gpu_metal": "SDK_ProcAmp.metal (just includes .cl)",
    "host": "SDK_ProcAmp_GPU.cpp",
    "log": "/Users/kiyotonakamamura/Desktop/SDK_ProcAmp_Debug.log"
  },
  
  "CRITICAL_RULES": {
    "multi_platform": "Update ALL THREE: CPU, CUDA, OpenCL when adding features",
    "cuda_is_reference": "CUDA is canonical - port to OpenCL/Metal",
    "metal_uses_opencl": "Metal includes OpenCL - maintain .cl only",
    "alpha_compositing": "ALWAYS use premultiplied alpha compositing: (srcColor * srcAlpha + dstColor * dstAlpha * (1-srcAlpha)) / outAlpha"
  },

  "V62_PREMULTIPLIED_ALPHA_COMPOSITING_FIX": {
    "problem": "White lines on white backgrounds showed gray edges during anti-aliasing/fade. Motion blur worked fine but non-motion-blur had visible artifacts.",
    "root_cause": {
      "description": "Motion blur code used correct premultiplied alpha compositing, but non-motion-blur code used straight alpha (lerp) compositing",
      "why_gray_edges": "Straight alpha: pixel.rgb = lerp(bg.rgb, line.rgb, alpha). When bg=(1,1,1) and line=(1,1,1) with alpha=0.3, result is (1,1,1) BUT pixel.alpha=0.3, causing Premiere to composite with black background → gray appearance",
      "correct_formula": "Premultiplied: pixel.rgb = (line.rgb * lineAlpha + bg.rgb * bgAlpha * (1 - lineAlpha)) / outAlpha"
    },
    "changes": {
      "shadow_compositing": {
        "old": "pixel.rgb = lerp(pixel.rgb, shadowColor, shadowBlend); pixel.alpha = max(pixel.alpha, shadowBlend)",
        "new": "Use premultiplied compositing matching motion blur: (shadowColor * shadowAlpha + pixel.rgb * pixel.alpha * (1-shadowAlpha)) / outAlpha",
        "benefit": "No gray edges on shadows"
      },
      "blend_modes_0_1": {
        "modes": "Back (0) and Front (1)",
        "old": "pixel.rgb = lerp(pixel.rgb, lineColor, coverage)",
        "new": "Premultiplied compositing: (lineColor * srcAlpha + pixel.rgb * pixel.alpha * (1-srcAlpha)) / outAlpha",
        "benefit": "Consistent with motion blur behavior"
      },
      "blend_mode_2": {
        "mode": "Back and Front",
        "back_lines": "Changed to premultiplied compositing",
        "front_lines": "Already used premultiplied (frontR = (lineColor * alpha + frontR * frontAlpha * (1-alpha)) / outAlpha)",
        "benefit": "Back and front now both use correct method"
      },
      "blend_mode_3": {
        "mode": "Alpha XOR",
        "old": "Line-to-line used lerp compositing",
        "new": "Premultiplied compositing for line-to-line blending",
        "xor_logic": "XOR with original element still applied after all lines drawn"
      },
      "removed_double_premultiply": {
        "issue": "Code had final 'pixel.rgb *= pixel.alpha' step that was wrong",
        "reason": "Premultiplied compositing already produces correct premultiplied output - no additional multiply needed",
        "fix": "Removed the final premultiplication step entirely"
      }
    },
    "formula_reference": {
      "premultiplied_compositing": "pixel.rgb = (srcColor * srcAlpha + dstColor * dstAlpha * (1 - srcAlpha)) / outAlpha; outAlpha = srcAlpha + dstAlpha * (1 - srcAlpha)",
      "why_correct": "This naturally handles all alpha values including partial coverage (anti-aliasing), fade effects, and maintains color accuracy on any background",
      "premiere_pro": "Premiere Pro expects premultiplied alpha format, so this is the only correct approach"
    },
    "files_modified": [
      "SDK_ProcAmp.cl (OpenCL/Metal - lines 555-640: all blend modes unified to premultiplied)",
      "SDK_ProcAmp.cl.bak (DELETED - was causing confusion with mismatched braces)"
    ],
    "testing": {
      "test_case": "White lines on white background with anti-aliasing enabled",
      "before": "Visible gray edges around line borders",
      "after": "Clean white edges, no gray artifacts",
      "confirmed": "2026-02-02 by user"
    },
    "future_note": "If adding any new blend mode or compositing operation, ALWAYS use premultiplied alpha formula from the start. Never use lerp/straight alpha for partial coverage."
  },

  "V61_EASING_REORGANIZATION_AND_LENGTH_ANIMATION": {
    "problem": "OutIn easing curves had incorrect behavior, easing menu was disorganized, length animation felt disconnected from travel",
    "changes": {
      "easing_menu_reorg": {
        "old_order": "0-23 (all base types), 24-27 (all OutIn types)",
        "new_order": "OutIn grouped with base families - 0: Linear, 1-2: SmoothStep, 3-6: Sine(In/Out/InOut/OutIn), 7-10: Quad, 11-14: Cubic, 15-18: Circ, 19-21: Back, 22-24: Elastic, 25-27: Bounce",
        "files": "SDK_ProcAmp_ParamNames.h (EASING_MENU), SDK_ProcAmp_GPU.cpp (ApplyEasing switch cases)"
      },
      "insine_outsine_swap_fix": {
        "problem": "InSine and OutSine implementations were reversed",
        "correction": "InSine=1-cos(π/2*t) (slow→fast), OutSine=sin(π/2*t) (fast→slow)"
      },
      "length_animation_unified": {
        "old_method": "Split extend/retract into separate halves (0→0.5, 0.5→1), each with different easing mappings",
        "new_method": "Unified sin(π*easedT) curve where easedT uses same easing as travel",
        "formula": "currentLength = maxLen * sin(π * ApplyEasing(t, easingType))",
        "benefit": "Length animation perfectly synchronized with travel easing - when travel is slow, length changes slow too",
        "behavior": "All easing types now feel natural - In(slow→fast), Out(fast→slow), InOut(slow→fast→slow), OutIn(fast→slow→fast) all work smoothly"
      },
      "round_cap_visual_fix": {
        "problem": "Round cap adds visual length (radius on each end), and short lines showed just a circle",
        "solution": "Subtract thickness from line length, clamp thickness when too short",
        "implementation": [
          "effectiveLength = currentLength - thickness (subtract both end caps)",
          "if effectiveLength < 0: effectiveThickness = currentLength, effectiveLength = 0",
          "Result: visual length matches parameter, no floating circles"
        ]
      },
      "appear_disappear_removed": {
        "reason": "Time-based appear/disappear had fixed easing that conflicted with user-selected easing, causing speed discontinuities at transitions",
        "solution": "Removed entirely - length animation (0→max→0) naturally handles appearance/disappearance",
        "benefit": "Smooth continuous easing throughout entire line lifetime"
      }
    },
    "technical_details": {
      "easing_application": "easedT = ApplyEasing(t, easingType) used for both travel position AND length curve input",
      "position_logic": "if easedT <= 0.5: tail fixed, head extends | else: head fixed, tail retracts",
      "data_structure": "d3 Float4 simplified to { 1.0f, 0.0f, 0.0f, 0.0f } (appearAlpha removed)"
    },
    "files_modified": [
      "SDK_ProcAmp_ParamNames.h (menu reorg)",
      "SDK_ProcAmp_GPU.cpp (ApplyEasing cases, ApplyEasingDerivative, length animation logic, round cap fix)"
    ]
  },

  "V55_APPEAR_DISAPPEAR_SCALE_FADE": {
    "note": "DEPRECATED in v61 - Removed due to easing conflicts. Length animation now handles appearance naturally.",
    "problem": "Lines appear/disappear abruptly (pop in/out)",
    "old_solution": "Added smooth scale + alpha fade animation at start and end of line lifetime",
    "implementation": {
      "appear": "First 5% of lifetime: easeOutQuad scale 0→1 AND alpha 0→1",
      "disappear": "Last 5% of lifetime: easeInQuad scale 1→0 AND alpha 1→0",
      "applied_to": {
        "scale": ["halfLen", "halfThick"],
        "alpha": ["coverage (line)", "scoverage (shadow)"]
      },
      "formula": "eased = 1 - (1 - t/0.05)^2 for appear, eased = ((1 - t) / 0.05)^2 for disappear"
    },
    "data_structure_change": {
      "lineData": "Now 4 Float4s per line (was 3): d0=position, d1=size, d2=color+velocity, d3=appearAlpha",
      "base_index": "lineIndex * 4 (was lineIndex * 3)"
    },
    "files_modified": ["SDK_ProcAmp_GPU.cpp", "SDK_ProcAmp_CPU.cpp", "SDK_ProcAmp.cu", "SDK_ProcAmp.cl"]
  },

  "V53_FIX_CRITICAL": {
    "problem": "Lines not rendering on Mac/Metal (CUDA worked fine)",
    "symptom": "No lines visible, no errors, kernel appeared to run",
    "root_cause": "Brace/bracket mismatch in SDK_ProcAmp.cl - line drawing code was INSIDE shadow if-block",
    "bad_code_structure": "if (inShadowEnable != 0) { shadow code... line color... line drawing... } // WRONG - line drawing inside shadow block!",
    "correct_structure": "if (inShadowEnable != 0) { shadow code only } // then line drawing OUTSIDE",
    "why_hard_to_find": [
      "No compile errors - syntax was valid",
      "No runtime errors - kernel executed",
      "CUDA version had correct structure - comparing line-by-line missed structural difference",
      "Indentation in .cl file was misleading - code looked correct visually"
    ],
    "debug_approach": [
      "1. Add simple test shape (red rectangle) to verify kernel runs",
      "2. If test shape appears, kernel pipeline is OK",
      "3. Problem is in rendering logic, not data passing",
      "4. Compare CUDA vs OpenCL STRUCTURE, not just syntax",
      "5. Check every if/else/for block has matching braces"
    ],
    "lesson": "When porting CUDA to OpenCL, verify BLOCK STRUCTURE matches exactly, not just line content"
  },
  
  "FLAT_ROUND_CAP_FIX": {
    "problem": "Flat/Round cap styles not switching correctly on Mac/Metal",
    "parameter": "inLineCap: 0 = Flat (box SDF), 1 = Round (capsule SDF)",
    "symptom": "Cap style appears stuck or wrong shape regardless of setting",
    "root_cause": "Same as V53 - if cap logic is inside wrong conditional block, only one path executes",
    "correct_implementation": {
      "locations_in_kernel": [
        "Shadow distance calculation (sdist)",
        "Line distance calculation (dist)"
      ],
      "flat_cap_sdf": {
        "description": "Box signed distance field",
        "code": [
          "float dxBox = fabs(px) - halfLen;",
          "float dyBox = fabs(py) - halfThick;",
          "float ox = dxBox > 0.0f ? dxBox : 0.0f;",
          "float oy = dyBox > 0.0f ? dyBox : 0.0f;",
          "float outside = sqrt(ox * ox + oy * oy);",
          "float inside = fmin(fmax(dxBox, dyBox), 0.0f);",
          "dist = outside + inside;"
        ]
      },
      "round_cap_sdf": {
        "description": "Capsule signed distance field",
        "code": [
          "float ax = fabs(px) - halfLen;",
          "float qx = ax > 0.0f ? ax : 0.0f;",
          "dist = sqrt(qx * qx + py * py) - halfThick;"
        ]
      }
    },
    "verification_steps": [
      "1. Ensure inLineCap parameter is passed to kernel (check buffer index)",
      "2. Verify if (inLineCap == 0) block is NOT inside another conditional",
      "3. Both shadow AND line drawing sections need the cap check",
      "4. Test with thick lines (thickness > 10) to see cap shape clearly"
    ],
    "common_mistakes": [
      "Cap check inside shadow-only block - line drawing ignores cap setting",
      "Using wrong variable name (lineCap vs inLineCap)",
      "Missing cap check in one of the three distance calculations"
    ],
    "reference": "CUDA SDK_ProcAmp.cu lines 252, 330, 374 have correct implementation"
  },
  
  "MOTION_BLUR_FIX": {
    "problem": "Motion blur implementation unified and corrected",
    "correct_behavior": "Motion blur now always trails BEHIND the moving line with standard uniform temporal sampling",
    "changes_v54": [
      "Removed SDK_PROCAMP_MOTION_BLUR_TYPE parameter from SDK_ProcAmp.h",
      "Removed MOTION_BLUR_TYPE_DFLT definition",
      "Removed blur type popup from SDK_ProcAmp_CPU.cpp ParamsSetup",
      "Fixed motionBlurType to 0 (Trail mode) in SDK_ProcAmp_GPU.cpp",
      "Removed type branching from SDK_ProcAmp.cl and SDK_ProcAmp.cu",
      "Removed P_BLUR_TYPE and related strings from SDK_ProcAmp_ParamNames.h"
    ],
    "changes_v54_1": [
      "CUDA implementation now matches OpenCL/Metal exactly",
      "Both use uniform temporal sampling with simple averaging",
      "Both use lineVelocity (instantaneous velocity from easing) for physically correct blur",
      "blurRange = effectiveVelocity * shutterFraction (where effectiveVelocity = pixelsPerFrame * lineVelocity)"
    ],
    "algorithm": {
      "description": "Standard motion blur with uniform temporal sampling",
      "formula": "coverage = Σ(sampleCoverage[i]) / numSamples",
      "sample_distribution": "Evenly distributed from -blurRange to 0 (trail behind)",
      "velocity_linked": "Blur length scales with instantaneous velocity (fast movement = longer blur)"
    },
    "files_modified": ["SDK_ProcAmp.h", "SDK_ProcAmp_CPU.cpp", "SDK_ProcAmp_GPU.cpp", "SDK_ProcAmp.cu", "SDK_ProcAmp.cl", "SDK_ProcAmp_ParamNames.h"]
  },
  
  "V51_FIX": {
    "problem": "Start Time/Duration not working on Mac",
    "cause": "Mac GPU-only rendering skips CPU, SharedClipData empty",
    "solution": "GPU fallback: clipStartFrame = GetClipStart() OR (mediaFrameIndex - clipOffset)",
    "result": "All parameters working on Mac and Windows"
  },
  
  "FRAME_CALCULATION": {
    "formula": "frameIndex = mediaFrameIndex - clipStartFrame",
    "mediaFrameIndex": "clipTime / ticksPerFrame",
    "clipStartFrame": "from CPU GetClipStart() or GPU fallback",
    "clipOffset": "Premiere parameter, 0 at clip start"
  },
  
  "GPU_SYNTAX_DIFF": {
    "decorators": {
      "cuda": "__device__ __forceinline__, __global__",
      "opencl": "inline, __kernel"
    },
    "math": {
      "cuda": "cosf, sinf, powf, fmaxf, fabsf, sqrtf, fminf",
      "opencl": "cos, sin, pow, fmax, fabs, sqrt, fmin"
    },
    "atomic": {
      "cuda": "atomicAdd(&counter[0], 1)",
      "opencl": "atomic_add(&counter[0], 1)",
      "metal": "atomic_fetch_add_explicit((device atomic_uint*)&counter[0], 1, memory_order_relaxed)"
    },
    "float4_init": {
      "cuda": "make_float4(0.0f, 0.0f, 0.0f, 0.0f)",
      "opencl": "(float4)(0.0f, 0.0f, 0.0f, 0.0f)"
    }
  },
  
  "METAL_GOTCHAS": {
    "buffer_init": "Never create Metal buffer with nullptr - use dummy data",
    "cpu_not_called": "Mac GPU-only may skip CPU - GPU needs fallback",
    "brace_structure": "OpenCL/Metal .cl file brace structure MUST match CUDA exactly"
  },
  
  "DEBUGGING_METAL_ISSUES": {
    "step1_verify_kernel_runs": "Add visible test shape (colored rectangle) at start of kernel",
    "step2_check_data_passing": "Visualize tile counts or line data with color coding",
    "step3_isolate_logic": "Comment out sections to find which block causes issue",
    "step4_compare_structure": "Use diff tool on CUDA vs OpenCL, focus on { } balance",
    "common_traps": [
      "Indentation looks correct but braces are wrong",
      "Code inside conditional that should be outside",
      "Missing closing brace causes entire section to be conditional",
      "OpenCL has no compiler warning for valid-but-wrong logic"
    ]
  },
  
  "BUILD": {
    "mac": "xcodebuild ARCHS=arm64, install to /Library/Application Support/Adobe/.../MediaCore/",
    "mac_clean": "xcodebuild clean before testing .cl changes - metallib may be cached",
    "windows": "Visual Studio SDK_ProcAmp.vcxproj"
  },
  
  "FEATURES": {
    "line_animation": "Head extends (tail fixed) → tail retracts (head fixed)",
    "wind_origin": "Adjusts spawn area position, NOT per-line animation",
    "color_system": "Single/Preset(33)/Custom(8) with per-line random selection",
    "blend_modes": "Back/Front/BackAndFront/AlphaXOR",
    "focus_dof": "Pseudo-blur via thickness + alpha (no Gaussian)",
    "effect_presets": "One-click parameter batch update (8 presets)",
    "spawn_scale": "X/Y separate spawn area expansion",
    "shadows": "Offset shadow with configurable color/offset/opacity"
  },
  
  "DO_NOT": [
    "Use seqTime for frame calc (cache issues)",
    "Use instance state for clip tracking (thread conflicts)",
    "Use mNodeID as key (changes frequently)",
    "Mix originOffset into line animation (spawn area only)",
    "Create Metal buffer with nullptr",
    "Use AEFX_CLR_STRUCT for param updates (loses metadata)",
    "Forget debounce for interactive controls",
    "Skip CPU implementation when adding GPU features",
    "Trust indentation in .cl files - always verify brace matching",
    "Assume 'no errors' means 'code is correct' in GPU kernels"
  ],
  
  "AI_TROUBLESHOOTING": {
    "easing_feels_wrong": "Check if length animation matches travel - should use same easedT = ApplyEasing(t, easingType) for both",
    "round_cap_issues": "Verify effectiveLength = currentLength - thickness, and thickness clamping when length < thickness",
    "speed_discontinuities": "Removed in v61 - length animation now unified with travel easing throughout entire lifetime",
    "mac_lines_not_rendering": "CHECK BRACE STRUCTURE FIRST - see V53_FIX_CRITICAL",
    "flat_round_not_working": "See FLAT_ROUND_CAP_FIX - check if cap logic is inside wrong conditional block, verify inLineCap passed correctly",
    "mac_bug": "Check SharedClipData, Metal buffer init, atomic syntax, BRACE STRUCTURE",
    "frame_timing": "Verify frameIndex calc, SharedClipData populated, GPU fallback",
    "param_not_updating": "Check SUPERVISE flag, params[] direct use, UpdateParamUI",
    "new_feature": "1.CUDA 2.OpenCL 3.CPU 4.Test both platforms 5.Update this JSON"
  }
}
