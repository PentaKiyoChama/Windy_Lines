{
  "AI_READ_ME_FIRST": {
    "project": "OST_WindyLines Wind Lines Effect",
    "version": "v64 - 2026-02-17",
    "status": "STABLE - Skew parameter added, OutIn easing dead-stop fixed, Mac Metal/OpenCL rendering fixed",
    "last_critical_fix": "v64: Fixed Mac Metal/OpenCL rendering failure caused by ProcAmp2Params struct field order mismatch with .cl kernel arguments"
  },
  
  "QUICK_REF": {
    "cpu": "OST_WindyLines_CPU.cpp",
    "gpu_cuda": "OST_WindyLines.cu (729 lines - REFERENCE)",
    "gpu_opencl": "OST_WindyLines.cl (733 lines)",
    "gpu_metal": "OST_WindyLines.metal (just includes .cl)",
    "host": "OST_WindyLines_GPU.cpp"
  },
  
  "CRITICAL_RULES": {
    "multi_platform": "Update ALL THREE: CPU, CUDA, OpenCL when adding features",
    "cuda_is_reference": "CUDA is canonical - port to OpenCL/Metal",
    "metal_uses_opencl": "Metal includes OpenCL - maintain .cl only",
    "metal_struct_alignment": "ProcAmp2Params struct field order MUST match .cl kernel argument order exactly - Metal passes struct as raw buffer",
    "alpha_compositing": "ALWAYS use premultiplied alpha compositing: (srcColor * srcAlpha + dstColor * dstAlpha * (1-srcAlpha)) / outAlpha",
    "motion_blur_cpu_gpu_sync": "CPU motion blur implementation must exactly match CUDA reference implementation"
  },

  "V64_SKEW_OUTIN_METAL_FIX": {
    "date": "2026-02-17",
    "changes": {
      "skew_parameter": {
        "description": "Added Skew (parallelogram shear) parameter to all backends",
        "transform": "px -= skew * py (applied in rotated local coordinates before SDF evaluation)",
        "range": "-2.0 to +2.0 (default: 0.0)",
        "enum_position": "OST_WINDYLINES_LINE_SKEW at index 28 (between LINE_ANGLE=27 and LINE_CAP=29)",
        "files_modified": ["OST_WindyLines.h", "OST_WindyLines_CPU.cpp", "OST_WindyLines_GPU.cpp", "OST_WindyLines.cu", "OST_WindyLines.cl"],
        "sdf_points": "Applied at all 5 SDF evaluation points (line body, shadow, motion blur samples)",
        "gpu_passing": {
          "cuda": "Individual kernel argument (inLineSkew after inLineCap)",
          "opencl": "clSetKernelArg index 65",
          "metal": "Via ProcAmp2Params struct (mLineSkew field after mMotionBlurVelocity)"
        }
      },
      "outin_easing_dead_stop_fix": {
        "description": "Fixed OutIn easing curves having complete velocity stop at midpoint (t=0.5)",
        "affected_types": "SineOutIn(case 6), QuadOutIn(case 10), CubicOutIn(case 14), CircOutIn(case 18)",
        "root_cause": "Piecewise OutIn derivative approaches zero at t=0.5, causing animation to freeze momentarily",
        "solution": "25% linear blend: return outIn * (1-k) + t * k where k=0.25",
        "file": "OST_WindyLines_Common.h",
        "previous_attempts": ["Smoothstep blend (caused backwards motion)", "15% linear blend (too subtle)"]
      },
      "mac_metal_opencl_rendering_fix": {
        "description": "Fixed lines not rendering on Mac (Metal/OpenCL) after Skew parameter addition",
        "root_cause_1": "mLineSkew was at struct position 21 (after mLineCap) but .cl kernel expects it at end (position 60) - caused ALL params from index 21 onward to be misaligned for Metal",
        "root_cause_2": "mMotionBlurType existed in ProcAmp2Params struct but NOT in .cl kernel - caused additional 1-field offset",
        "fix_1": "Moved mLineSkew to end of kernel params section (after mMotionBlurVelocity) in struct",
        "fix_2": "Moved mMotionBlurType from kernel params section to CPU-only section in struct",
        "critical_lesson": "Metal passes ProcAmp2Params as raw buffer at index 5 - struct field order MUST exactly match .cl kernel argument order",
        "file": "OST_WindyLines_GPU.cpp"
      }
    },
    "verification": {
      "windows_cuda": "Verify lines render with Skew applied - CUDA uses individual args, struct changes don't affect it",
      "mac_metal": "Verify lines render on Mac - critical to confirm struct/kernel alignment is correct",
      "outin_easing": "Test SineOutIn/QuadOutIn/CubicOutIn/CircOutIn - animation should maintain continuous motion through midpoint"
    }
  },

  "V63_CPU_MOTION_BLUR_FIX": {
    "date": "2026-02-04",
    "problem": "CPU motion blur rendering showed gray trail artifacts on motion-blurred samples, while GPU (CUDA/OpenCL/Metal) rendered correctly with proper alpha falloff",
    "root_cause": {
      "double_premultiplication": "PRIMARY CAUSE - CPU code applied premultiplication (outV *= a, outU *= a) AFTER premultiplied alpha compositing, causing double multiplication and loss of color saturation",
      "result": "Double premultiplication darkened colors (red 0.5 * 0.3 = 0.15), making motion blur trails appear gray instead of naturally fading to background"
    },
    "DETAILED_TECHNICAL_EXPLANATION": {
      "what_is_premultiplied_alpha_compositing": {
        "purpose": "Correct way to blend two semi-transparent layers, accounting for partial coverage/transparency",
        "formula": "resultColor = (srcColor * srcAlpha + dstColor * dstAlpha * (1 - srcAlpha)) / outAlpha",
        "where": {
          "srcColor": "Color of the new element being drawn (e.g., red line)",
          "srcAlpha": "Alpha/coverage of the new element (0.0 = fully transparent, 1.0 = fully opaque)",
          "dstColor": "Color of existing pixel (e.g., white background)",
          "dstAlpha": "Alpha of existing pixel",
          "outAlpha": "Resulting alpha = srcAlpha + dstAlpha * (1 - srcAlpha)"
        },
        "output_format": "This formula produces STRAIGHT ALPHA (also called unassociated alpha) - color values are NOT multiplied by alpha",
        "key_point": "The division by outAlpha normalizes the color, producing straight alpha output"
      },
      "what_was_wrong_in_cpu_code": {
        "step1_correct_compositing": {
          "description": "CPU code correctly used premultiplied alpha compositing formula",
          "example_code": "outV = (paletteV[ci] * srcAlpha + outV * a * invAlpha) / outAlpha;",
          "result": "This produces correct straight alpha color (color NOT multiplied by alpha)"
        },
        "step2_incorrect_multiplication": {
          "description": "THEN CPU code incorrectly multiplied the result by alpha again",
          "example_code": "outV *= a; outU *= a;",
          "result": "This converts straight alpha to premultiplied alpha, but Premiere Pro expects straight alpha"
        },
        "why_this_is_wrong": "Multiplying by alpha a second time darkens the color. The compositing formula already produced the correct answer - additional multiplication corrupts it."
      },
      "concrete_numerical_example": {
        "scenario": "Red line with motion blur (coverage=0.3) over white background",
        "input_values": {
          "background": "White in YUV: Y=1.0, U=0.0, V=0.0, alpha=1.0 (or 0.0 if hideElement=true)",
          "line_color": "Red in YUV: Y=0.3, U=0.0, V=0.5 (V channel makes it red)",
          "coverage": "0.3 (motion blur sample at 30% opacity)"
        },
        "correct_calculation": {
          "step1_compositing": "outV = (0.5 * 0.3 + 0.0 * 1.0 * 0.7) / 0.3 = 0.15 / 0.3 = 0.5",
          "step1_alpha": "outAlpha = 0.3 + 1.0 * 0.7 = 1.0",
          "step2_output": "outV = 0.5, alpha = 0.3 (if hideElement) or 1.0 (if not)",
          "visual_result": "Red color (V=0.5) with 30% opacity over background → RED fades naturally to background",
          "note": "When hideElement=false and background is white (alpha=1.0), final alpha stays 1.0 (opaque), and color blends correctly via compositing"
        },
        "wrong_calculation_before_fix": {
          "step1_compositing": "outV = (0.5 * 0.3 + 0.0 * 1.0 * 0.7) / 0.3 = 0.5 (CORRECT so far)",
          "step1_alpha": "outAlpha = 0.3",
          "step2_double_premultiply": "outV *= 0.3 → outV = 0.5 * 0.3 = 0.15 (WRONG!)",
          "step3_output": "outV = 0.15, alpha = 0.3",
          "visual_result": "Darkened color (V=0.15 instead of 0.5) → appears GRAY/DESATURATED",
          "why_gray": "V=0.15 is much less saturated than V=0.5. In YUV, lower V values move toward gray. The color lost its redness."
        },
        "comparison": {
          "correct": "V=0.5 with alpha=0.3 → Red fades naturally",
          "wrong": "V=0.15 with alpha=0.3 → Gray appearance (lost saturation)",
          "saturation_loss": "0.5 → 0.15 = 70% saturation loss"
        }
      },
      "why_motion_blur_made_it_obvious": {
        "motion_blur_creates_partial_coverage": "Motion blur samples have varying coverage (0.1, 0.2, 0.3, etc.), creating many semi-transparent pixels",
        "straight_alpha_behavior": "With correct straight alpha: Red stays red regardless of alpha value. Background shows through proportionally.",
        "double_premultiply_behavior": "With double premultiplication: Color darkens proportionally to alpha. Low alpha = very dark/gray color.",
        "trail_appearance": {
          "correct": "Red → Red → Red → transparent (color stays consistent, only alpha changes)",
          "wrong": "Red → Pink → Gray → transparent (color darkens/desaturates as alpha decreases)"
        },
        "without_motion_blur": "Fully opaque lines (alpha=1.0) had no visible issue because 1.0 * 1.0 = 1.0 (no change)"
      },
      "the_fix": {
        "what_was_removed": {
          "line1": "if (originalAlpha >= 0.99f) { a = 1.0f; }",
          "line2": "outV *= a;",
          "line3": "outU *= a;",
          "location": "OST_WindyLines_CPU.cpp lines 2143-2154 (before pixel output)"
        },
        "why_removal_fixes_it": "Premultiplied alpha compositing already produces correct straight alpha output. No additional multiplication is needed or wanted.",
        "after_fix": {
          "code": "((float*)destData)[x * 4 + 0] = outV; // Direct output",
          "behavior": "Colors maintain full saturation at all alpha values",
          "result": "Motion blur trails fade naturally via alpha, color stays consistent"
        }
      },
      "difference_from_gpu": {
        "gpu_never_had_this_bug": "CUDA/OpenCL/Metal implementations output pixel.x, pixel.y, pixel.z, pixel.w directly after compositing - no additional multiplication",
        "cpu_had_extra_code": "CPU had legacy code that attempted to 'prepare' output for Premiere Pro by premultiplying, but this was incorrect",
        "why_legacy_code_existed": "Possibly misunderstanding about Premiere Pro's expected format, or copy-paste from older code that used different alpha conventions"
      }
    },
    "changes": {
      "removed_double_premultiplication": {
        "old": "outV *= a; outU *= a; after premultiplied compositing calculation",
        "new": "Direct output without additional multiplication - premultiplied compositing already produces correct straight alpha result",
        "benefit": "FIXES GRAY ARTIFACTS - colors maintain saturation, motion blur trails fade naturally via alpha only",
        "explanation": "Premultiplied alpha compositing formula (lineColor * srcAlpha + bgColor * bgAlpha * (1-srcAlpha)) / outAlpha already produces correct straight alpha color. Additional *= a was multiplying colors a second time, reducing saturation.",
        "location": "OST_WindyLines_CPU.cpp lines 2143-2154"
      },
      "shadow_motion_blur_restored": {
        "note": "Initially removed shadow motion blur thinking it was related to the issue, but restored after identifying true cause was double premultiplication",
        "implementation": "Shadows now use motion blur sampling matching OpenCL/Metal implementation",
        "benefit": "Consistent motion blur appearance across both lines and shadows"
      },
      "motion_blur_calculation_unified": {
        "change": "Replaced smoothstep() helper with explicit CUDA-style calculation",
        "formula": "if (aa > 0.0f) { tt = saturate((distSample - aa) / (0.0f - aa)); sampleCoverage = tt * tt * (3.0f - 2.0f * tt) * tailFade; }",
        "applied_to": ["Line motion blur samples", "Shadow motion blur samples", "Blur too small fallback", "No motion blur single sample"]
      }
    },
    "verification": "Test with red lines on white background with motion blur enabled - trails should fade naturally maintaining red color, not turning gray. Shadows should also show smooth motion blur.",
    "future_note": "NEVER multiply colors by alpha after premultiplied alpha compositing - the compositing formula already produces correct straight alpha output. Additional multiplication causes color darkening/desaturation."
  },

  "V62_PREMULTIPLIED_ALPHA_COMPOSITING_FIX": {
    "problem": "White lines on white backgrounds showed gray edges during anti-aliasing/fade. Motion blur worked fine but non-motion-blur had visible artifacts.",
    "root_cause": {
      "description": "Motion blur code used correct premultiplied alpha compositing, but non-motion-blur code used straight alpha (lerp) compositing",
      "why_gray_edges": "Straight alpha: pixel.rgb = lerp(bg.rgb, line.rgb, alpha). When bg=(1,1,1) and line=(1,1,1) with alpha=0.3, result is (1,1,1) BUT pixel.alpha=0.3, causing Premiere to composite with black background → gray appearance",
      "correct_formula": "Premultiplied: pixel.rgb = (line.rgb * lineAlpha + bg.rgb * bgAlpha * (1 - lineAlpha)) / outAlpha"
    },
    "changes": {
      "shadow_compositing": {
        "old": "pixel.rgb = lerp(pixel.rgb, shadowColor, shadowBlend); pixel.alpha = max(pixel.alpha, shadowBlend)",
        "new": "Use premultiplied compositing matching motion blur: (shadowColor * shadowAlpha + pixel.rgb * pixel.alpha * (1-shadowAlpha)) / outAlpha",
        "benefit": "No gray edges on shadows"
      },
      "blend_modes_0_1": {
        "modes": "Back (0) and Front (1)",
        "old": "pixel.rgb = lerp(pixel.rgb, lineColor, coverage)",
        "new": "Premultiplied compositing: (lineColor * srcAlpha + pixel.rgb * pixel.alpha * (1-srcAlpha)) / outAlpha",
        "benefit": "Consistent with motion blur behavior"
      },
      "blend_mode_2": {
        "mode": "Back and Front",
        "back_lines": "Changed to premultiplied compositing",
        "front_lines_accumulation": "Changed from premultiplied to un-premultiplied accumulation to match OpenCL: frontR = (lineColor * alpha + frontR * frontAlpha * (1-alpha)) / outAlpha",
        "front_lines_application": "Changed from 'frontR * frontA' to 'frontR' to match OpenCL working implementation",
        "why_changed": "CUDA had premultiplied accumulation + premultiplied application which caused red/gray edge artifacts in Back and Front mode with anti-aliasing. OpenCL used un-premultiplied accumulation + direct application (frontR without multiply), which worked correctly.",
        "benefit": "Back and Front mode now shows clean edges without red or gray artifacts, matching OpenCL/Metal behavior"
      },
      "blend_mode_3": {
        "mode": "Alpha XOR",
        "old": "Line-to-line used lerp compositing",
        "new": "Premultiplied compositing for line-to-line blending",
        "xor_logic": "XOR with original element still applied after all lines drawn"
      },
      "removed_double_premultiply": {
        "issue": "Code had final 'pixel.rgb *= pixel.alpha' step that was wrong",
        "reason": "Premultiplied compositing already produces correct premultiplied output - no additional multiply needed",
        "fix": "Removed the final premultiplication step entirely"
      }
    },
    "formula_reference": {
      "premultiplied_compositing": "pixel.rgb = (srcColor * srcAlpha + dstColor * dstAlpha * (1 - srcAlpha)) / outAlpha; outAlpha = srcAlpha + dstAlpha * (1 - srcAlpha)",
      "why_correct": "This naturally handles all alpha values including partial coverage (anti-aliasing), fade effects, and maintains color accuracy on any background",
      "premiere_pro": "Premiere Pro expects premultiplied alpha format, so this is the only correct approach"
    },
    "files_modified": [
      "OST_WindyLines.cl (OpenCL/Metal - lines 555-640: all blend modes unified to premultiplied)",
      "OST_WindyLines.cu (CUDA - lines 285-315 Shadow, 470-530 Blend Modes, 512-522 Front line accumulation fix)",
      "OST_WindyLines_CPU.cpp (CPU - lines 1850-1970 Shadow and Blend Modes, 1959-1969 Front line accumulation fix)",
      "OST_WindyLines.cl.bak (DELETED - was causing confusion with mismatched braces)"
    ],
    "future_note": "If adding any new blend mode or compositing operation, ALWAYS use premultiplied alpha formula from the start. Never use lerp/straight alpha for partial coverage."
  },

  "V61_EASING_REORGANIZATION_AND_LENGTH_ANIMATION": {
    "problem": "OutIn easing curves had incorrect behavior, easing menu was disorganized, length animation felt disconnected from travel",
    "changes": {
      "easing_menu_reorg": {
        "old_order": "0-23 (all base types), 24-27 (all OutIn types)",
        "new_order": "OutIn grouped with base families - 0: Linear, 1-2: SmoothStep, 3-6: Sine(In/Out/InOut/OutIn), 7-10: Quad, 11-14: Cubic, 15-18: Circ, 19-21: Back, 22-24: Elastic, 25-27: Bounce",
        "files": "OST_WindyLines_ParamNames.h (EASING_MENU), OST_WindyLines_GPU.cpp (ApplyEasing switch cases)"
      },
      "insine_outsine_swap_fix": {
        "problem": "InSine and OutSine implementations were reversed",
        "correction": "InSine=1-cos(π/2*t) (slow→fast), OutSine=sin(π/2*t) (fast→slow)"
      },
      "length_animation_unified": {
        "old_method": "Split extend/retract into separate halves (0→0.5, 0.5→1), each with different easing mappings",
        "new_method": "Unified sin(π*easedT) curve where easedT uses same easing as travel",
        "formula": "currentLength = maxLen * sin(π * ApplyEasing(t, easingType))",
        "benefit": "Length animation perfectly synchronized with travel easing - when travel is slow, length changes slow too",
        "behavior": "All easing types now feel natural - In(slow→fast), Out(fast→slow), InOut(slow→fast→slow), OutIn(fast→slow→fast) all work smoothly"
      },
      "round_cap_visual_fix": {
        "problem": "Round cap adds visual length (radius on each end), and short lines showed just a circle",
        "solution": "Subtract thickness from line length, clamp thickness when too short",
        "implementation": [
          "effectiveLength = currentLength - thickness (subtract both end caps)",
          "if effectiveLength < 0: effectiveThickness = currentLength, effectiveLength = 0",
          "Result: visual length matches parameter, no floating circles"
        ]
      },
      "appear_disappear_removed": {
        "reason": "Time-based appear/disappear had fixed easing that conflicted with user-selected easing, causing speed discontinuities at transitions",
        "solution": "Removed entirely - length animation (0→max→0) naturally handles appearance/disappearance",
        "benefit": "Smooth continuous easing throughout entire line lifetime"
      }
    },
    "technical_details": {
      "easing_application": "easedT = ApplyEasing(t, easingType) used for both travel position AND length curve input",
      "position_logic": "if easedT <= 0.5: tail fixed, head extends | else: head fixed, tail retracts",
      "data_structure": "d3 Float4 simplified to { 1.0f, 0.0f, 0.0f, 0.0f } (appearAlpha removed)"
    },
    "files_modified": [
      "OST_WindyLines_ParamNames.h (menu reorg)",
      "OST_WindyLines_GPU.cpp (ApplyEasing cases, ApplyEasingDerivative, length animation logic, round cap fix)"
    ]
  },

  "V55_APPEAR_DISAPPEAR_SCALE_FADE": {
    "note": "DEPRECATED in v61 - Removed due to easing conflicts. Length animation now handles appearance naturally.",
    "problem": "Lines appear/disappear abruptly (pop in/out)",
    "old_solution": "Added smooth scale + alpha fade animation at start and end of line lifetime",
    "implementation": {
      "appear": "First 5% of lifetime: easeOutQuad scale 0→1 AND alpha 0→1",
      "disappear": "Last 5% of lifetime: easeInQuad scale 1→0 AND alpha 1→0",
      "applied_to": {
        "scale": ["halfLen", "halfThick"],
        "alpha": ["coverage (line)", "scoverage (shadow)"]
      },
      "formula": "eased = 1 - (1 - t/0.05)^2 for appear, eased = ((1 - t) / 0.05)^2 for disappear"
    },
    "data_structure_change": {
      "lineData": "Now 4 Float4s per line (was 3): d0=position, d1=size, d2=color+velocity, d3=appearAlpha",
      "base_index": "lineIndex * 4 (was lineIndex * 3)"
    },
    "files_modified": ["OST_WindyLines_GPU.cpp", "OST_WindyLines_CPU.cpp", "OST_WindyLines.cu", "OST_WindyLines.cl"]
  },

  "V53_FIX_CRITICAL": {
    "problem": "Lines not rendering on Mac/Metal (CUDA worked fine)",
    "symptom": "No lines visible, no errors, kernel appeared to run",
    "root_cause": "Brace/bracket mismatch in OST_WindyLines.cl - line drawing code was INSIDE shadow if-block",
    "bad_code_structure": "if (inShadowEnable != 0) { shadow code... line color... line drawing... } // WRONG - line drawing inside shadow block!",
    "correct_structure": "if (inShadowEnable != 0) { shadow code only } // then line drawing OUTSIDE",
    "why_hard_to_find": [
      "No compile errors - syntax was valid",
      "No runtime errors - kernel executed",
      "CUDA version had correct structure - comparing line-by-line missed structural difference",
      "Indentation in .cl file was misleading - code looked correct visually"
    ]
  },
  
  "FLAT_ROUND_CAP_FIX": {
    "problem": "Flat/Round cap styles not switching correctly on Mac/Metal",
    "parameter": "inLineCap: 0 = Flat (box SDF), 1 = Round (capsule SDF)",
    "symptom": "Cap style appears stuck or wrong shape regardless of setting",
    "root_cause": "Same as V53 - if cap logic is inside wrong conditional block, only one path executes",
    "correct_implementation": {
      "locations_in_kernel": [
        "Shadow distance calculation (sdist)",
        "Line distance calculation (dist)"
      ],
      "flat_cap_sdf": {
        "description": "Box signed distance field",
        "code": [
          "float dxBox = fabs(px) - halfLen;",
          "float dyBox = fabs(py) - halfThick;",
          "float ox = dxBox > 0.0f ? dxBox : 0.0f;",
          "float oy = dyBox > 0.0f ? dyBox : 0.0f;",
          "float outside = sqrt(ox * ox + oy * oy);",
          "float inside = fmin(fmax(dxBox, dyBox), 0.0f);",
          "dist = outside + inside;"
        ]
      },
      "round_cap_sdf": {
        "description": "Capsule signed distance field",
        "code": [
          "float ax = fabs(px) - halfLen;",
          "float qx = ax > 0.0f ? ax : 0.0f;",
          "dist = sqrt(qx * qx + py * py) - halfThick;"
        ]
      }
    },
    "verification_steps": [
      "1. Ensure inLineCap parameter is passed to kernel (check buffer index)",
      "2. Verify if (inLineCap == 0) block is NOT inside another conditional",
      "3. Both shadow AND line drawing sections need the cap check",
      "4. Test with thick lines (thickness > 10) to see cap shape clearly"
    ],
    "common_mistakes": [
      "Cap check inside shadow-only block - line drawing ignores cap setting",
      "Using wrong variable name (lineCap vs inLineCap)",
      "Missing cap check in one of the three distance calculations"
    ],
    "reference": "CUDA OST_WindyLines.cu lines 252, 330, 374 have correct implementation"
  },
  
  "MOTION_BLUR_FIX": {
    "problem": "Motion blur implementation unified and corrected",
    "correct_behavior": "Motion blur now always trails BEHIND the moving line with standard uniform temporal sampling",
    "changes_v54": [
      "Removed OST_WINDYLINES_MOTION_BLUR_TYPE parameter from OST_WindyLines.h",
      "Removed MOTION_BLUR_TYPE_DFLT definition",
      "Removed blur type popup from OST_WindyLines_CPU.cpp ParamsSetup",
      "Fixed motionBlurType to 0 (Trail mode) in OST_WindyLines_GPU.cpp",
      "Removed type branching from OST_WindyLines.cl and OST_WindyLines.cu",
      "Removed P_BLUR_TYPE and related strings from OST_WindyLines_ParamNames.h"
    ],
    "changes_v54_1": [
      "CUDA implementation now matches OpenCL/Metal exactly",
      "Both use uniform temporal sampling with simple averaging",
      "Both use lineVelocity (instantaneous velocity from easing) for physically correct blur",
      "blurRange = effectiveVelocity * shutterFraction (where effectiveVelocity = pixelsPerFrame * lineVelocity)"
    ],
    "algorithm": {
      "description": "Standard motion blur with uniform temporal sampling",
      "formula": "coverage = Σ(sampleCoverage[i]) / numSamples",
      "sample_distribution": "Evenly distributed from -blurRange to 0 (trail behind)",
      "velocity_linked": "Blur length scales with instantaneous velocity (fast movement = longer blur)"
    },
    "files_modified": ["OST_WindyLines.h", "OST_WindyLines_CPU.cpp", "OST_WindyLines_GPU.cpp", "OST_WindyLines.cu", "OST_WindyLines.cl", "OST_WindyLines_ParamNames.h"]
  },
  
  "V51_FIX": {
    "problem": "Start Time/Duration not working on Mac",
    "cause": "Mac GPU-only rendering skips CPU, SharedClipData empty",
    "solution": "GPU fallback: clipStartFrame = GetClipStart() OR (mediaFrameIndex - clipOffset)",
    "result": "All parameters working on Mac and Windows"
  },
  
  "FRAME_CALCULATION": {
    "formula": "frameIndex = mediaFrameIndex - clipStartFrame",
    "mediaFrameIndex": "clipTime / ticksPerFrame",
    "clipStartFrame": "from CPU GetClipStart() or GPU fallback",
    "clipOffset": "Premiere parameter, 0 at clip start"
  },
  
  "GPU_SYNTAX_DIFF": {
    "decorators": {
      "cuda": "__device__ __forceinline__, __global__",
      "opencl": "inline, __kernel"
    },
    "math": {
      "cuda": "cosf, sinf, powf, fmaxf, fabsf, sqrtf, fminf",
      "opencl": "cos, sin, pow, fmax, fabs, sqrt, fmin"
    },
    "atomic": {
      "cuda": "atomicAdd(&counter[0], 1)",
      "opencl": "atomic_add(&counter[0], 1)",
      "metal": "atomic_fetch_add_explicit((device atomic_uint*)&counter[0], 1, memory_order_relaxed)"
    },
    "float4_init": {
      "cuda": "make_float4(0.0f, 0.0f, 0.0f, 0.0f)",
      "opencl": "(float4)(0.0f, 0.0f, 0.0f, 0.0f)"
    }
  },
  
  "METAL_GOTCHAS": {
    "buffer_init": "Never create Metal buffer with nullptr - use dummy data",
    "cpu_not_called": "Mac GPU-only may skip CPU - GPU needs fallback",
    "brace_structure": "OpenCL/Metal .cl file brace structure MUST match CUDA exactly"
  },
  
  "DEBUGGING_METAL_ISSUES": {
    "step1_verify_kernel_runs": "Add visible test shape (colored rectangle) at start of kernel",
    "step2_check_data_passing": "Visualize tile counts or line data with color coding",
    "step3_isolate_logic": "Comment out sections to find which block causes issue",
    "step4_compare_structure": "Use diff tool on CUDA vs OpenCL, focus on { } balance",
    "common_traps": [
      "Indentation looks correct but braces are wrong",
      "Code inside conditional that should be outside",
      "Missing closing brace causes entire section to be conditional",
      "OpenCL has no compiler warning for valid-but-wrong logic"
    ]
  },
  
  "BUILD": {
    "mac": "xcodebuild ARCHS=arm64, install to /Library/Application Support/Adobe/.../MediaCore/",
    "mac_clean": "xcodebuild clean before testing .cl changes - metallib may be cached",
    "windows": "Visual Studio OST_WindyLines.vcxproj"
  },
  
  "FEATURES": {
    "line_animation": "Head extends (tail fixed) → tail retracts (head fixed)",
    "wind_origin": "Adjusts spawn area position, NOT per-line animation",
    "color_system": "Single/Preset(33)/Custom(8) with per-line random selection",
    "blend_modes": "Back/Front/BackAndFront/AlphaXOR",
    "focus_dof": "Pseudo-blur via thickness + alpha (no Gaussian)",
    "effect_presets": "One-click parameter batch update (8 presets)",
    "spawn_scale": "X/Y separate spawn area expansion",
    "shadows": "Offset shadow with configurable color/offset/opacity",
    "skew": "Parallelogram shear transform (px -= skew * py), range -2 to +2, applied in rotated local coordinates before SDF evaluation",
    "easing": "28 types including OutIn variants with 25% linear blend to avoid dead-stop at midpoint"
  },
  
  "DO_NOT": [
    "Use seqTime for frame calc (cache issues)",
    "Use instance state for clip tracking (thread conflicts)",
    "Use mNodeID as key (changes frequently)",
    "Mix originOffset into line animation (spawn area only)",
    "Create Metal buffer with nullptr",
    "Use AEFX_CLR_STRUCT for param updates (loses metadata)",
    "Forget debounce for interactive controls",
    "Skip CPU implementation when adding GPU features",
    "Trust indentation in .cl files - always verify brace matching",
    "Assume 'no errors' means 'code is correct' in GPU kernels"
  ],
  
  "AI_TROUBLESHOOTING": {
    "easing_feels_wrong": "Check if length animation matches travel - should use same easedT = ApplyEasing(t, easingType) for both",
    "round_cap_issues": "Verify effectiveLength = currentLength - thickness, and thickness clamping when length < thickness",
    "speed_discontinuities": "Removed in v61 - length animation now unified with travel easing throughout entire lifetime",
    "outin_dead_stop": "OutIn easing now uses 25% linear blend (k=0.25) to avoid zero-velocity at midpoint. If stop is visible, increase k in OST_WindyLines_Common.h",
    "mac_lines_not_rendering": "CHECK ProcAmp2Params STRUCT ORDER FIRST - struct fields must match .cl kernel argument order exactly for Metal. Also check BRACE STRUCTURE (V53)",
    "skew_not_working": "Verify: (1) enum position matches PF_ADD order, (2) px -= skew * py applied at ALL SDF evaluation points, (3) NaN/range clamping with isnan() guard",
    "flat_round_not_working": "See FLAT_ROUND_CAP_FIX - check if cap logic is inside wrong conditional block, verify inLineCap passed correctly",
    "mac_bug": "Check ProcAmp2Params struct/kernel alignment, SharedClipData, Metal buffer init, atomic syntax, BRACE STRUCTURE",
    "frame_timing": "Verify frameIndex calc, SharedClipData populated, GPU fallback",
    "param_not_updating": "Check SUPERVISE flag, params[] direct use, UpdateParamUI",
    "lines_appear_thicker_with_aa": "EXPECTED BEHAVIOR - See ANTIALIASING_VISUAL_THICKNESS_EFFECT below. aa adds smooth fade zone that makes lines visually thicker. This is standard anti-aliasing behavior.",
    "new_feature": "1.CUDA 2.OpenCL 3.CPU 4.Test both platforms 5.Update this JSON"
  },

  "ANTIALIASING_VISUAL_THICKNESS_EFFECT": {
    "date": "2026-02-08",
    "issue": "Lines appear slightly thicker when increasing anti-aliasing parameter (aa)",
    "status": "VERIFIED - This is EXPECTED BEHAVIOR, not a bug",
    "technical_explanation": {
      "how_aa_works": {
        "parameter": "OST_WINDYLINES_LINE_AA (range: 0-5, default: 1)",
        "purpose": "Controls width of smooth edge transition for anti-aliasing",
        "implementation": "Hermite smoothstep: coverage = tt * tt * (3 - 2*tt) where tt = (aa - dist) / aa",
        "effect": "Creates smooth fade-out zone extending aa pixels beyond geometric line edge"
      },
      "why_lines_appear_thicker": {
        "core_thickness": "halfThick parameter defines geometric line center to edge distance - this NEVER changes",
        "fade_zone": "aa parameter adds semi-transparent pixels beyond the geometric edge",
        "visual_perception": "Human vision integrates semi-transparent pixels, making line appear thicker",
        "standard_behavior": "This is universal in computer graphics - all anti-aliasing systems have this characteristic"
      },
      "mathematical_proof": {
        "formula": "coverage = smoothstep((aa - dist) / aa) where dist is distance from geometric edge",
        "at_edge": "dist=0: coverage=1.0 (100% opaque)",
        "at_50_percent": "dist=aa/2: coverage≈0.5 (50% opaque, perceived visual edge)",
        "at_aa_boundary": "dist=aa: coverage=0.0 (fully transparent)",
        "visual_edge_location": "50% opacity threshold is at distance halfThick + aa/2 from center"
      },
      "numerical_examples": {
        "thin_line_10px": {
          "halfThick": 5.0,
          "aa_0": { "visual_width": "10.00px", "increase": "0%" },
          "aa_1": { "visual_width": "11.00px", "increase": "10%" },
          "aa_2": { "visual_width": "12.00px", "increase": "20%" },
          "aa_5": { "visual_width": "15.00px", "increase": "50%" }
        },
        "thick_line_20px": {
          "halfThick": 10.0,
          "aa_0": { "visual_width": "20.00px", "increase": "0%" },
          "aa_1": { "visual_width": "21.00px", "increase": "5%" },
          "aa_2": { "visual_width": "22.00px", "increase": "10%" },
          "aa_5": { "visual_width": "25.00px", "increase": "25%" }
        },
        "observation": "Visual thickness increase is proportional to aa value but less noticeable percentage-wise for thicker lines"
      }
    },
    "code_locations": {
      "smoothstep_calculation": {
        "cuda": "OST_WindyLines.cu lines 504-507, 539-542",
        "opencl": "OST_WindyLines.cl lines 527-528, 555-556",
        "cpu": "OST_WindyLines_CPU.cpp lines 2600-2602, 2625-2627",
        "formula": "tt = saturate((dist - aa) / (0.0f - aa)); coverage = tt * tt * (3.0f - 2.0f * tt)"
      },
      "bounding_box": {
        "location": "OST_WindyLines_GPU.cpp line 2015",
        "code": "const float radius = fabsf(segCenterX) + halfLen + halfThick + aa;",
        "reason": "Extends render region to include anti-aliased pixels, prevents edge clipping"
      },
      "parameter_definition": "OST_WindyLines.h lines 329-333 (LINE_AA_MIN_VALUE=0, LINE_AA_MAX_VALUE=5, LINE_AA_DFLT=1)"
    },
    "user_recommendations": {
      "default": "aa=1.0 (default) - Optimal balance for most cases",
      "thin_lines": "aa=0.5-1.0 - Minimal visual thickness increase, use when size precision is critical",
      "normal_use": "aa=1.0-2.0 - Good smoothness with acceptable visual thickness increase",
      "artistic": "aa=3.0-5.0 - Maximum smoothness, use only when smoothness is more important than precise sizing",
      "no_antialiasing": "aa=0.0 - No smoothing, sharp edges, true geometric size (but may appear jagged)"
    },
    "verification": {
      "script": "verify_antialiasing.py - Python script with exact smoothstep implementation and numerical analysis",
      "documentation": "ANTIALIASING_ANALYSIS.md - Comprehensive bilingual (Japanese/English) technical documentation",
      "conclusion": "NO CODE CHANGES NEEDED - Anti-aliasing is working exactly as designed"
    },
    "comparison_to_other_systems": {
      "opengl_msaa": "Multisample anti-aliasing (MSAA) - also increases visual edge thickness via sub-pixel coverage",
      "font_rendering": "FreeType/DirectWrite - all use similar smoothstep for font edges, same visual thickness effect",
      "image_scaling": "Bicubic/Lanczos - create soft edges that appear slightly larger than nearest-neighbor",
      "universal_principle": "Smooth edges ALWAYS appear thicker than hard edges due to human visual perception integrating semi-transparent pixels"
    },
    "trade_off": {
      "smoothness_vs_size": "This is an inherent trade-off in computer graphics - smoother edges require wider transition zones",
      "cannot_be_eliminated": "It is physically impossible to have both infinitely sharp edges AND smooth anti-aliasing simultaneously",
      "user_choice": "Users must choose their preference via the aa parameter based on their specific needs"
    },
    "future_note": "If users report lines being 'too thick' with anti-aliasing, direct them to ANTIALIASING_ANALYSIS.md and recommend adjusting aa parameter downward (e.g., from 1.0 to 0.5) rather than changing code. The implementation is correct."
  }
}
