#!/usr/bin/env python3
"""
Color Preset Converter: TSV to C++ Color Preset Arrays (Proof of Concept)
Usage: python color_preset_converter_POC.py [color_presets.tsv]
Output: SDK_ProcAmp_ColorPresets.h

This is a proof-of-concept demonstrating the feasibility of the color preset
TSV conversion system, analogous to the existing preset_converter.py for effect presets.
"""

import sys
import csv
import os

def parse_tsv(filepath):
    """Parse TSV file and return list of color preset dictionaries"""
    presets = []
    with open(filepath, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f, delimiter='\t')
        for row_num, row in enumerate(reader, start=2):  # start=2 because line 1 is header
            # Skip empty rows (no id field)
            if not row.get('id') or not row['id'].strip():
                continue
            
            try:
                preset = {
                    'id': int(row['id']),
                    'name': row['name'],
                    'name_en': row['name_en'],
                    'colors': []
                }
                # Parse 8 colors
                for i in range(1, 9):
                    color_str = row[f'color{i}']
                    parts = color_str.split(',')
                    if len(parts) != 4:
                        raise ValueError(f"Invalid color format in preset {preset['name']}: {color_str}")
                    a, r, g, b = map(int, parts)
                    # Validate range
                    if not all(0 <= v <= 255 for v in [a, r, g, b]):
                        raise ValueError(f"Color values must be 0-255 in preset {preset['name']}: {color_str}")
                    preset['colors'].append((a, r, g, b))
                presets.append(preset)
            except (ValueError, KeyError) as e:
                raise ValueError(f"Error at row {row_num}: {e}")
    return presets

def format_preset_cpp(preset):
    """Convert a preset dictionary to C++ array initializer"""
    name_en = preset['name_en']
    name_jp = preset['name']
    
    cpp = f'\t// {name_jp} ({name_en})\n'
    cpp += f'\tconst PresetColor k{name_en}[8] = {{\n'
    
    # Format colors: 4 per line for readability
    colors = []
    for a, r, g, b in preset['colors']:
        colors.append(f'{{{a}, {r}, {g}, {b}}}')
    
    for i in range(0, 8, 4):
        line = ', '.join(colors[i:i+4])
        cpp += f'\t\t{line}'
        if i + 4 < 8:
            cpp += ',\n'
        else:
            cpp += '\n'
    
    cpp += '\t};\n'
    return cpp

def generate_lookup_function(presets):
    """Generate GetPresetPalette() switch-case function"""
    cpp = '// Preset color lookup table\n'
    cpp += 'inline const PresetColor* GetPresetPalette(int presetIndex) {\n'
    cpp += '\tswitch (presetIndex) {\n'
    
    for preset in presets:
        preset_id = preset['id']
        name_en = preset['name_en']
        cpp += f'\t\tcase {preset_id}: return ColorPresets::k{name_en};\n'
    
    cpp += '\t\tdefault: return ColorPresets::kRainbow;  // Fallback to first preset\n'
    cpp += '\t}\n'
    cpp += '}\n'
    
    return cpp

def generate_enum(presets):
    """Generate ColorPreset enum"""
    cpp = '// Color preset enum - auto-generated from TSV\n'
    cpp += 'enum ColorPreset\n'
    cpp += '{\n'
    
    for i, preset in enumerate(presets):
        name_en = preset['name_en']
        # Convert to uppercase with underscores (e.g., "test_color" -> "TEST_COLOR")
        enum_name = 'COLOR_PRESET_' + name_en.upper()
        
        if i == 0:
            # First preset starts at 1
            cpp += f'\t{enum_name} = 1,\n'
        else:
            cpp += f'\t{enum_name},\n'
    
    cpp += '\tCOLOR_PRESET_COUNT\n'
    cpp += '};\n'
    
    return cpp

def generate_cpp_header(presets):
    """Generate complete C++ header file"""
    # Header guard and comments
    cpp = '// Auto-generated by color_preset_converter.py - DO NOT EDIT MANUALLY\n'
    cpp += '// Edit color_presets.tsv and run color_preset_converter.py to regenerate\n\n'
    cpp += '#ifndef SDK_PROCAMP_COLOR_PRESETS_H\n'
    cpp += '#define SDK_PROCAMP_COLOR_PRESETS_H\n\n'
    cpp += '#include <string>\n\n'
    
    # Enum definition
    cpp += generate_enum(presets)
    cpp += '\n'
    
    # PresetColor struct definition
    cpp += '// Color structure (ARGB format)\n'
    cpp += 'struct PresetColor {\n'
    cpp += '\tunsigned char a, r, g, b;\n'
    cpp += '};\n\n'
    
    # Namespace with all preset definitions
    cpp += '// Preset color palettes (8 colors each)\n'
    cpp += 'namespace ColorPresets {\n'
    
    preset_codes = []
    for preset in presets:
        preset_codes.append(format_preset_cpp(preset))
    
    cpp += '\n'.join(preset_codes)
    cpp += '}\n\n'
    
    # Lookup function
    cpp += generate_lookup_function(presets)
    cpp += '\n'
    
    # Preset count constant (for dynamic UI generation)
    cpp += f'// Total number of color presets (for UI generation)\n'
    cpp += f'static const int kColorPresetCount = {len(presets)};\n\n'
    
    # Unified preset count: Single(1) + Sep(1) + Custom(1) + Sep(1) + Presets(N)
    # Note: Separators (-|) are displayed as items in the menu but are not selectable
    cpp += f'// Total number of menu items including separators\n'
    cpp += f'// Single=1 + Sep=1 + Custom=1 + Sep=1 + Presets={len(presets)} = {1 + 1 + 1 + 1 + len(presets)}\n'
    cpp += f'static const int kUnifiedPresetCount = {1 + 1 + 1 + 1 + len(presets)};\n\n'
    
    # Preset names array (for UI labels)
    cpp += '// Preset names (Japanese) for UI labels\n'
    cpp += 'static const char* kColorPresetNames[] = {\n'
    for i, preset in enumerate(presets):
        cpp += f'\t"{preset["name"]}"'
        if i < len(presets) - 1:
            cpp += ','
        cpp += f'  // {preset["name_en"]}\n'
    cpp += '};\n\n'
    
    # Unified menu string generator
    cpp += '// Generate unified preset menu string (Single|(-|Custom|(-|Preset1|Preset2|...)\n'
    cpp += 'inline const char* GetUnifiedPresetMenuString() {\n'
    cpp += '\tstatic std::string menuStr;\n'
    cpp += '\tif (menuStr.empty()) {\n'
    cpp += '\t\tmenuStr = "単色|(-|カスタム|(-";\n'
    cpp += '\t\tfor (int i = 0; i < kColorPresetCount; ++i) {\n'
    cpp += '\t\t\tmenuStr += "|";\n'
    cpp += '\t\t\tmenuStr += kColorPresetNames[i];\n'
    cpp += '\t\t}\n'
    cpp += '\t}\n'
    cpp += '\treturn menuStr.c_str();\n'
    cpp += '}\n\n'
    
    # Index conversion functions
    # Note: Separators (-|) ARE included in menu numbering
    # Menu display: Single|(-|Custom|(-|Rainbow|Pastel|Forest|...
    # UI values (1-based): 1=Single, 2=Sep, 3=Custom, 4=Sep, 5=Rainbow, 6=Pastel, 7=Forest, ...
    # After normalization (0-based): 0=Single, 1=Sep, 2=Custom, 3=Sep, 4=Rainbow, 5=Pastel, 6=Forest, ...
    cpp += '// Convert unified preset index (0-based after normalization) to color mode and preset index\n'
    cpp += '// Note: Separators (-|) ARE included in menu numbering\n'
    cpp += '// UI values: 1=Single, 2=Sep, 3=Custom, 4=Sep, 5=Rainbow, 6=Pastel, ...\n'
    cpp += 'inline void UnifiedIndexToColorModeAndPreset(int unifiedIndex, int& outColorMode, int& outPresetIndex) {\n'
    cpp += '\tif (unifiedIndex == 0) {\n'
    cpp += '\t\toutColorMode = 0;  // Single\n'
    cpp += '\t\toutPresetIndex = 0;\n'
    cpp += '\t} else if (unifiedIndex == 1 || unifiedIndex == 3) {\n'
    cpp += '\t\t// Separator (not selectable, but treat as first preset to avoid errors)\n'
    cpp += '\t\toutColorMode = 2;\n'
    cpp += '\t\toutPresetIndex = 0;\n'
    cpp += '\t} else if (unifiedIndex == 2) {\n'
    cpp += '\t\toutColorMode = 1;  // Custom\n'
    cpp += '\t\toutPresetIndex = 0;\n'
    cpp += '\t} else if (unifiedIndex >= 4 && unifiedIndex < 4 + ' + str(len(presets)) + ') {\n'
    cpp += '\t\toutColorMode = 2;  // Preset\n'
    cpp += '\t\toutPresetIndex = unifiedIndex - 4;  // 0-based preset index\n'
    cpp += '\t} else {\n'
    cpp += '\t\t// Out of range - default to first preset\n'
    cpp += '\t\toutColorMode = 2;\n'
    cpp += '\t\toutPresetIndex = 0;\n'
    cpp += '\t}\n'
    cpp += '}\n\n'
    
    # Reverse conversion function
    cpp += '// Convert color mode and preset index back to unified index\n'
    cpp += 'inline int ColorModeAndPresetToUnifiedIndex(int colorMode, int presetIndex) {\n'
    cpp += '\tif (colorMode == 0) return 0;  // Single\n'
    cpp += '\tif (colorMode == 1) return 2;  // Custom\n'
    cpp += '\tif (colorMode == 2) {  // Preset\n'
    cpp += '\t\tint idx = presetIndex + 4;  // Skip Single, Sep, Custom, Sep\n'
    cpp += '\t\tif (idx >= 4 && idx < 4 + ' + str(len(presets)) + ') return idx;\n'
    cpp += '\t\treturn 4;  // Default to first preset\n'
    cpp += '\t}\n'
    cpp += '\treturn 0;  // Default to Single\n'
    cpp += '}\n'
    
    # Footer
    cpp += '\n#endif // SDK_PROCAMP_COLOR_PRESETS_H\n'
    
    return cpp

def main():
    # Default to same directory's color_presets.tsv
    if len(sys.argv) >= 2:
        tsv_file = sys.argv[1]
    else:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        tsv_file = os.path.join(script_dir, 'color_presets.tsv')
    
    try:
        print(f"Reading color presets from: {tsv_file}")
        presets = parse_tsv(tsv_file)
        
        print(f"Parsed {len(presets)} color presets")
        
        cpp_code = generate_cpp_header(presets)
        
        # Save to header file in script directory
        script_dir = os.path.dirname(os.path.abspath(__file__))
        output_file = os.path.join(script_dir, 'SDK_ProcAmp_ColorPresets.h')
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(cpp_code)
        
        print(f"✓ Generated: {output_file}")
        print(f"✓ Total color presets: {len(presets)}")
        print(f"✓ Total colors: {len(presets) * 8}")
        
        # Summary
        print("\nPreset Summary:")
        for preset in presets:
            print(f"  [{preset['id']}] {preset['name']} ({preset['name_en']})")
        
    except FileNotFoundError:
        print(f"✗ Error: File '{tsv_file}' not found")
        print(f"  Please create a color_presets.tsv file or specify the path")
        sys.exit(1)
    except KeyError as e:
        print(f"✗ Error: Missing column in TSV: {e}")
        print(f"  Required columns: id, name, name_en, color1-color8")
        sys.exit(1)
    except ValueError as e:
        print(f"✗ Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"✗ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main()
